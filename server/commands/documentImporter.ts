import emojiRegex from "emoji-regex";
import mime from "mime-types";
import type { Node } from "prosemirror-model";
import truncate from "lodash/truncate";
import parseTitle from "@shared/utils/parseTitle";
import type { ProsemirrorData } from "@shared/types";
import { ProsemirrorHelper as SharedProsemirrorHelper } from "@shared/utils/ProsemirrorHelper";
import { DocumentValidation } from "@shared/validations";
import { serializer } from "@server/editor";
import { traceFunction } from "@server/logging/tracing";
import type { User } from "@server/models";
import { ProsemirrorHelper } from "@server/models/helpers/ProsemirrorHelper";
import { TextHelper } from "@server/models/helpers/TextHelper";
import type { APIContext } from "@server/types";
import { DocumentConverter } from "@server/utils/DocumentConverter";
import { InvalidRequestError } from "../errors";

type Props = {
  user: User;
  mimeType: string;
  fileName: string;
  content: Buffer | string;
  ctx: APIContext;
};

type ImportResult = {
  icon?: string;
  text: string;
  title: string;
  state: Buffer;
};

/**
 * Converts document content to state and validates size constraints.
 *
 * @param content The document content as markdown text or Prosemirror JSON.
 * @param title The document title (used in error messages).
 * @returns The Y.Doc state buffer.
 */
function convertToState(
  content: string | ProsemirrorData,
  title: string
): Buffer {
  const ydoc = ProsemirrorHelper.toYDoc(content);
  const state = ProsemirrorHelper.toState(ydoc);

  if (state.length > DocumentValidation.maxStateLength) {
    throw InvalidRequestError(
      `The document "${title}" is too large to import, please reduce the length and try again`
    );
  }

  return state;
}

/**
 * Imports HTML content directly to Prosemirror, bypassing markdown conversion.
 */
async function importHtml(
  content: Buffer | string,
  title: string,
  user: User,
  ctx: APIContext
): Promise<ImportResult> {
  let doc: Node = DocumentConverter.htmlToProsemirror(content);

  // Extract title from first H1 if present
  const headings = SharedProsemirrorHelper.getHeadings(doc);
  if (headings.length > 0 && headings[0].level === 1) {
    title = headings[0].title;
    doc = ProsemirrorHelper.removeFirstHeading(doc);
  }

  // Extract emoji from start of document
  const { emoji: icon, doc: docWithoutEmoji } =
    ProsemirrorHelper.extractEmojiFromStart(doc);
  doc = docWithoutEmoji;

  // Replace external images with attachments
  doc = await TextHelper.replaceImagesWithAttachmentsInNode(ctx, doc, user);

  const text = serializer.serialize(doc);
  title = truncate(title, { length: DocumentValidation.maxTitleLength });
  const state = convertToState(doc.toJSON(), title);

  return { text, state, title, icon };
}

/**
 * Imports content via markdown conversion (for docx, md, csv, etc.).
 */
async function importMarkdown(
  content: Buffer | string,
  fileName: string,
  mimeType: string,
  title: string,
  user: User,
  ctx: APIContext
): Promise<ImportResult> {
  let text = await DocumentConverter.convertToMarkdown(
    content,
    fileName,
    mimeType
  );

  // Find and extract emoji near the beginning of the document
  const regex = emojiRegex();
  const matches = regex.exec(text.slice(0, 10));
  const icon = matches ? matches[0] : undefined;
  if (icon) {
    text = text.replace(icon, "");
  }

  // If the first line looks like a markdown heading, use it as the title
  if (text.startsWith("# ")) {
    const result = parseTitle(text);
    title = result.title;
    text = text.replace(/^.+(\n|$)/, "");
  }

  // Replace any <br> generated by turndown with escaped newlines
  text = text.trim().replace(/<br>/gi, "\\n");

  // Remove any closed and immediately reopened formatting marks
  text = text.replace(/\*\*\*\*/gi, "").replace(/____/gi, "");

  text = await TextHelper.replaceImagesWithAttachments(ctx, text, user);

  // Sanity check â€“ text cannot possibly be longer than state
  if (text.length > DocumentValidation.maxStateLength) {
    throw InvalidRequestError(
      `The document "${title}" is too large to import, please reduce the length and try again`
    );
  }

  title = truncate(title, { length: DocumentValidation.maxTitleLength });
  const state = convertToState(text, title);

  return { text, state, title, icon };
}

async function documentImporter({
  mimeType,
  fileName,
  content,
  user,
  ctx,
}: Props): Promise<ImportResult> {
  // Find valid extensions and remove them from the title
  const extensions = [
    "docx",
    "md",
    "markdown",
    "html",
    ...(mime.extensions[mimeType] ?? []),
  ];
  const title = fileName.replace(
    new RegExp(`\\.(${extensions.join("|")})$`, "i"),
    ""
  );

  const isHtml = mimeType === "text/html" || fileName.endsWith(".html");

  if (isHtml) {
    return importHtml(content, title, user, ctx);
  }

  return importMarkdown(content, fileName, mimeType, title, user, ctx);
}

export default traceFunction({
  spanName: "documentImporter",
})(documentImporter);
